% 6. Post-Mortem 
\chapter{Postmortem Documentation}
\label{chap:postmortem}
This chapter attempts to identify and spell out the causes of the project failure. The project timeline will allow a quantitative overview of the project progression and show what parts of the project slowed down progress. Then, an overview of the qualitative aspects of the deliverables will discuss the maturity of the implementation and which parts reached a satisfactory level.

\section{Quantitative Overview: Time Management}
Comparing the planned thesis schedule to the actual course it has taken, this section discusses how the intended plan was implemented and changed at certain places. Also, it will examine the causes of the delays during development.
\label{sec:project-timeline}
\subsection{Project timeline}
Table \ref{fig:thesis-schedule} shows the initially planned thesis schedule divided into four phases, laying out the course of the thesis over a span of 24 weeks.

\begin{table}
    \centering
    \begin{tabular}{l l}
        \toprule
        Phase / Task             & Duration              \\
        \midrule
        1. Preparation           & $4$ weeks ($16,67\%$) \\
        \midrule
        Literature Research      & $1$ week              \\
        Expert Interviews        & $1$ week              \\
        Testbed Configuration    & $2$ weeks             \\
        \midrule
        2. Prototype             & $7$ weeks ($29,17\%$) \\
        \midrule
        Prototype Conception     & $2$ weeks             \\
        Prototype Implementation & $4$ weeks             \\
        Expert Feedback          & $1$ week              \\
        \midrule
        3. Release Candidate     & $7$ weeks ($29,17\%$) \\
        \midrule
        RC Conception            & $2$ weeks             \\
        RC Implementation        & $4$ weeks             \\
        Expert Feedback          & $1$ week              \\
        \midrule
        4. Finalization          & $6$ weeks ($25\%$)    \\
        \midrule
        MQTT Case Study          & $2$ weeks             \\
        Thesis Finalization      & $4$ weeks             \\
        \midrule
        \midrule
        Total                    & $24$ weeks            \\
        \bottomrule
    \end{tabular}
    \caption{Initially planned schedule for the thesis}
    \label{fig:thesis-schedule}
\end{table}

\paragraph{1. Preparation} The initial phase covered preparation tasks for further work on the thesis. Literature research on the topics covered and touched in this thesis was carried out. Related work on \ac{IoT} and \ac{ICS} security analysis (as discussed in chapter \ref{chap:related-work} were of special interest as those showed what approaches had been taken to assess security implementations. Also, a testbed (shown in \ref{sec:prototype-testing} for running the proxy application was built. A decision was made against conducting expert interviews before implementing a first prototype on the basis that practical experience with the subject matter could benefit the expert interviews. The fact that a number of important questions arose from work on the first prototype later proved this decision to be correct. Performing the literature research and building testbed was completed within the intended schedule of three weeks.
\paragraph{2. Prototype} In the second phase, the prototype discussed in section \ref{sec:prototypical-implementation} was designed and implemented in weekly sprints. Preceding these sprints, a rough design of the prototype's architecture and runtime behaviour was worked out in one week that would serve as a base for further design refinement and implementation in the sprints. These sprints ran for eight weeks in total: the initial design turned out to be too oversimplified so that sprints aiming to design and implement specific components were conducted rather isolated from other components that still needed to be worked on. As a result, both the integration of individual components and their interaction would fail and require redesigns and time-consuming adjustments to their implementation. Also, neither was the prototype mature enough to be used as a proxy application, nor was the resulting design and implementation clean enough to suggest putting further effort into working on them. After these eight sprints, work on this prototype was stopped and the expert interviews discussed in section \ref{sec:interviews} were prepared and conducted.
\paragraph{3. Release Candidate} The third phase was intended to yield a fully functional proxy application. This was initiated by switching the technology stack from TypeScript to Python and re-designing and re-implementing large parts of the first prototype. In order to avoid the same mistake of refining a vague design concept and spending time adjusting the design and implementation to make them work, two weeks were spent on a new design concept shown in section \ref{sec:abstract-design-concept}. This concept did not only define single components (discussed in section \ref{sec:individual-components}) but also interfaces that specified how those components interacted with each other, aiming for clear separation of components and high flexibility in implementation. Components of the prototype that were independent of the communication protocols used at runtime, such as NetStacks and \acp{FSM}, were implemented first over the span of four weeks. Then, implementations for supporting the \ac{HTTP}, \ac{WS} and \ac{MQTT} protocols followed over a span of another six weeks. Work on this prototype was stopped after those ten weeks as the technical difficulties discussed in paragraph \ref{par:challenges} made estimations over the remaining time needed to finish the prototype both hard to make and rather unreliable.
\paragraph{4. Finalization} The final phase was intended to conduct a case study on how the proxy application would perform on scenario \# 2 from section \ref{sec:example-scenarios}. Tests were made to run the proxy application in the testbed shown in section \ref{sec:prototype-testing} which featured the same communication protocols that were used in scenario \# 2. However, the proxy application failed to reliably transmit or encode the messages sent between the \ac{MQTT} client and broker, thus resulting in a broken communication channel. The complex runtime behaviour and very time-consuming debugging of the proxy application (further elaborated on in paragraph \ref{par:challenges}) lead to the decision to stop the project.

\begin{table}
    \centering
    \begin{tabular}{l l}
        \toprule
        Phase / Task             & Duration            \\
        \midrule
        1. Preparation           & $3$ weeks ($12\%$)  \\
        \midrule
        Literature Research      & 1 week              \\
        Testbed Configuration    & 2 weeks             \\
        \midrule
        2. TypeScript Prototype  & $10$ weeks ($40\%$) \\
        \midrule
        Prototype Conception     & 1 week              \\
        Prototype Implementation & 8 weeks             \\
        Expert Interviews        & 1 week              \\
        \midrule
        3. Python Candidate      & $12$ weeks ($48\%$) \\
        \midrule
        RC Conception            & 2 weeks             \\
        RC Implementation        & 10 weeks            \\
        \midrule
        \midrule
        Total                    & 25 weeks            \\
        \bottomrule
    \end{tabular}
    \caption{Actual schedule of the project}
    \label{fig:thesis-schedule-actual}
\end{table}

Table \ref{fig:thesis-schedule-actual} shows the actual schedule of the thesis. As can be seen, $88\%$ ($22$ weeks) of the time working on the thesis was spent designing and implementing the prototypes compared to a planned portion of roughly $60\%$ ($14$ weeks).

% Typescript prototype: mar2020
% Python prototype: november2020-december2021

\subsection{Development challenges}
\label{par:challenges}
There were a series of development challenges that slowed down implementation of both prototypes considerably:
\paragraph{Complex runtime behaviour}
\paragraph{Time-consuming debugging}
\paragraph{Poor documentation}
\paragraph{Race-conditions}

% \begin{itemize}
%     \item \emph{Complex runtime behaviour}
%     \item \emph{Race-conditions: newly arrived messages could change states in state-machines, decoupling network stacks and causing currently processed messages that were processed up to raise null pointer exceptions.}
%     \item \emph{Poor documentation: some open-source libraries (e.g. python's \ac{WS} library) were poorly documented, resulting in days worth of diving through source code.}
%     \item \emph{Time-consuming debugging: testing scenario \# 2 meant loading a large configuration file, resulting in dynamic and long pipelines and interweaving of multiple state-machines and pipelines. Tracing messages became very time-consuming and confusing.}
% \end{itemize}

\section{Qualitative: Deliverables}
\label{sec:tool-selection}
\emph{TBD: Which fit-criteria were met? What is the implementation currently capable of? Which requirements were not full-filled?}